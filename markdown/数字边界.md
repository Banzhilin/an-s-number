<center>
#浮点表示
</center>

##一个例子
<p>
我们在编程时或多或少会接触到有关于浮点计算，在其结果保留小数位时会发现有的计算会与真实计算的值出现偏差，例如下述代码段：
<p>

<code>

	#include <cstdio>
	int main(){
      double x = 1.555;
      double y = 3.555;
      char str[] = "x = %.?f\ty = %.?f\n";
      printf("x = %f\ty = %f\n",x,y);
      for(int i = 2;i <= 5;++i){
          str[6] = str[15] = '0'+i;
          printf(str,x,y);
      }

</code>

![](https://github.com/Banzhilin/an-s-number/blob/master/markdown/test.png)
<p>
从上述的代码段中我们可以看出，在对于1.555和3.555保留两位小数时，其出现了不同的结果，对于1.555的结果为1.55，3.555的结果为3.55，我们的第一反应是不是程序的舍入算法存在BUG？为了印证我们的猜想，我们进一步对程序进行DEBUG，以此查看程序的值变化：
<p>
![](https://github.com/Banzhilin/an-s-number/blob/master/markdown/testDEBUG.png)
<p>
从DEBUG的结果来看，错误并不是由于程序的舍入算法的错误引发的，而从DEBUG的结果我们可以清晰的发现错误出现在数据的存储表示上，1.555与3.555在程序中并是真实的存储了1.555和3.555，它们存在一些偏差。为了搞清楚为什么会出现表示上的偏差，我们需要进一步的深入了解：

- 计算机到底是怎么表示浮点数的？

- 以及为什么会出现存储偏差？

##背景
###整数的表示
<p>
在计算机中对于整数的表示，我们采用将十进制的整数转化为二进制的表示，在将二进制以0、1的有意义序列存储在存储介质上，以此来暂存或长期存储数据。
<p>
<p>
其十进制与二进制的转化采用的是**除二取余法**，如下图所示：
<p>
![](https://github.com/Banzhilin/an-s-number/blob/master/markdown/整数表示.png)
<p>
如果是负整数，一般是先对其绝对值除二取余，然后再对其结果取反加1（即补码表示），至于为什么要用不补码表示，其主要目的是为了方便二进制的计算，详见xiaolingcoding.com
<p>
###浮点数的表示
<p>
在介绍完了整数的表示，我们再来看看计算机是怎么表示和存储浮点数的
<p>
<p>
先来看小数是怎么转化到二进制的，对于整数部分采用前面所提到的**除二取余法**，而小数部分采用的是**乘二取整法**，即对于小数点后的部分每次乘2，当其值小于1时这一位表示为0，否则表示为1，并对于乘得的结果再减一；如此循环，直到减的结果为0时结束，在计算得到整数加小数的结果后，将其拼接，再使用移位+科学计数法来表示浮点数，其操作过程以及存储形式如下图：
<p>

![](https://github.com/Banzhilin/an-s-number/blob/master/markdown/浮点数表示.png)

<p>
然而不是所有浮点数都可以用确切的二进制表示，对于小数的表示是一种不断拟合的结果，当我们将二进制小数回转为十进制时可以清楚的体会到，如下：
<p>

![](https://github.com/Banzhilin/an-s-number/blob/master/markdown/浮点数循环.png)

<p>
其当为全1，且位数无限多时，其结果收敛为1，在一般的情况下（0、1混合），其表现形式为不断向真实值收敛，其结果是：

- 与真实的小数值相等

- 不断拟合真实值，位数无限，其无法用有限位的二进制来表示，只可以表示其近似值
<p>
<p>
##从上述的表示方法中看来：
- 对于整数可以用二进制精确表示，在其数据宽度范围内（二进制的位数）
- 对于小数表示，并不是所有小数一定可以用有限位数来表示,其结果导致
	- 对于不可以用有限位的二进制表示的小数，我们的做法是使用足够多可用表示的二进制位来表示其数据，当其在转化为十进制是，表现出来的现象为，其结果分布在真实值非常接近的上下侧（大一点点或小一点点），由此造成了精度丢失。
<p>


##回到例子
<p>
我们分别来计算其浮点数的二进制表，之后再将二进制转为十进制，以此来模拟程序的**存储-使用**过程，如下图：
<p>

![](https://github.com/Banzhilin/an-s-number/blob/master/markdown/example.png)

<p>
从上述的计算中我们可以了解到，出现上述例子的根本原因是由于在浮点十进制在转化为二进制时，小数无法用有限位来具体表示，则不得不采用尽量以较多位的资源来表示数据，但是这样表示的仅仅为一个近似的数据，其发生了精度缺失

而在我们使用的编译器中，一般会记录使用者使用的浮点数的小数的有效位数，在表示为二进制时，尽量的使用多位表示，当其在转回十进制时，其值是可以通过之前保存的有效位数来四舍五入重新获取的。
<p>


##一些解决方法
###一个简单方法
此处仅为个人解决此问题的一个可行思路：


- 我们的目的是高精度表示和计算，同时在之前的介绍中，发现对于其整数部分是不会出现精度缺失的，故而我们需要着重处理小数部分 
	- 设计一个数据结构，其中包含long long类型的数据，其保存数据的整数部分；对于小数部分定义一个char*来以字符的形式来存储，再设置一个bool值来表示正负情况，故此，我们就可以在存储介质存储下一个没有精度缺失的数据了，并且在取出时也没有精度缺失。
	
	- 由于数据的存储表示形式发生了改变，故而其计算方式也需要重新设计，其主要方法为：

		- 先扫描判断原始数据，将其整数，小数部分分别存储在对应位置，并对其正负性判断
		
		- 先计算小数部分，其是用字符表示的，故而在计算中，需要对计算双方对位，即比较两者的长度，以较短者的末尾开向前开始计算，过10进一，直到第一位，得注意进位借位标志，判定其是否需要进位借位；由此完成小数部分计算
		
		- 对于整数部分由于直接是由long long数据类型表示的，可以直接计算，但要注意小数进位借位的情况。  

- 上述方法，其仅为一个粗略的构想，其时间和空间复杂度还是相对较高，如果要优化，其可以从下述几个方面出发:

	- 再整数表示部分，不规定使用long long数据类型，可以让用户指定数据类型，以此来按需存储，其可以通过C++类似的模板参数来指定

	- 对于小数部分的计算优化，一个char占8位，其表示的数据位0~255（无符号），其对于我需求只需要表示0~9，故此其可以再此不用char来表示一个小数位，其可以使用4个比特位来表示一个小数数字，以此来节约空间；具体做法可以为

		- 设计一个数据解构，其中数据位为用户指定的位数，类似于C++里的位域使用方法。

		- 再对于数据赋值时可以使用union{位域数组，一个等长的其它数据}来赋值，主要使用一个其它等长数据来对于位域赋值。

		- 再计算和读数时其，按四位一步长的方式来获取数据，即位域数组索引加一。

	- 上述都是依靠单纯的加减为讨论基础，当要进行乘除等复杂运算时，其可以模拟低层乘除的处理方式，即累加或累减，其超出了讨论范围，如有兴趣，可以自行查找资料。


